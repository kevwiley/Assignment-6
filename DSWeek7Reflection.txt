The recursive insertion worked by checking if each node of the tree was empty. For example, if a string was entered to be the root, it was checked if the root node was empty. If it was empty, the value was entered, if it wasn’t the value wasn't entered and the recursion ended. It is similar when adding values to the left and right child nodes. The function calls itself to look through each node until it finds an open spot or doesn’t. I think getting used to the way recursion worked was the biggest challenge for me. Usually if you need code to run multiple times you just use a loop, but I can see with this assignment how that could get messy with big trees. I think in cases like these recursion is very important. Finally, trees may be preferable compared to real world data structures when dealing with data that needs to be searched through from top level to bottom. For example, with trees it is easy to see who works for who in a company’s organization with managers and employees. Trees may also be preferred when data needs to be sorted quickly. If users know what category data belongs to, they can easily follow a tree down to the specific spot where the data is.